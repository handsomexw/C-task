复习：
1、使用指针需要注意的问题
    空指针：指针变量的值为NULL叫做空指针
            对空指针解引用时会产生段错误，对来历不明的指针解引用前先判断
            1、函数参数是指针类型时，使用前先判断
            2、对于函数的返回值是指针类型时，拿到后先判断
            空指针可以作为一种错误标志，如果函数返回NULL表示函数执行出错
                return NULL;
        野指针：值不确定的指针，对野指针解引用的后果：
            1、一切正常
            2、段错误
            3、脏数据
            野指针的危害更大，因为无法判断出是否是野指针，而且错误是隐藏性
            你是如何避免产生野指针：
                1、定义指针变量时一定要初始化，一般初始化为NULL
                2、函数不要返回栈内存的地址
                3、当指针指向的内存被销毁时，要及时把指针变量置空

2、指针运算符：
    指针变量只有以下运算符有意义：
        指针+n 前进n个元素
        指针-n 后退n个元素
        指针-指针 计算出两个指针之间间隔了多少个元素，必须同类型指针才能相减
3、const与指针
    const int* p;       保护指向的内存数据不被修改
    int const * p;
    int* const p;       保护指针变量不被修改
    const int* const p; 都保护
    int const * const p;   
4、指针数组和数组指针
    指针数组：成员是指针的数组
        int* arr[10];
    数组指针：专门指向数组的指针
        int (*arrp)[10];
5、数组名与指针区别
    数组名是数组的首地址，它与数组首地址内存是映射关系，相当于特殊的指针，是常量、不可被修改
    所以数组名可以解引用，指针也可以使用中括号，当成数组使用
        arr[i] == p[i]
        *(p+i) == *(arr+i)
6、二级指针
    二级指针就是指向指针的指针，用来存储指针变量的地址
        定义：类型** 变量_pp;
        赋值：变量_pp = &指针变量;
        解引用：*变量_pp == 指针变量
                **变量_pp == *指针变量 == 内存数据
            
    当需要共享指针变量时，传递指针变量的地址

7、函数指针
    函数指针是用来指向函数的指针，函数名就是函数在代码段中的内存首地址
    调用函数本质上是让进程跳转到函数所在的代码段中执行二进制指令
    如何函数指针中存储了函数的首地址，对函数指针解引用可以执行函数
    定义函数指针：
        返回值 (*函数指针名)(类型1,类型2,...);
    赋值：
        函数指针名 = 函数名;
    解引用：
        函数指针名(实参); // 函数名(实参)

    当函数中需要调用后面写的函数时，可以在函数的参数中提供函数指针，调用后面写的函数，这种方式叫做函数回调
        qsort

一、什么是堆内存
    是进程的一个内存段(text\data\bss\heap\stack)，由程序员手动管理
    优点足够大，缺点使用麻烦

二、为什么要使用堆内存
    1、随着程序的复杂，数据量变多
    2、其它内存段的申请释放不受控制，堆内存的申请释放受控制，可以适时地节约内存

三、如何使用堆内存
    注意：C语言中没有控制堆内存的语句，只能使用C标准库中的函数
    #include <stdlib.h>

    void *malloc(size_t size);
    功能：从堆内存中申请size个字节的内存，申请到的内存中数据的值不确定
    返回值：成功返回申请到的连续内存的首地址，失败返回NULL

    void free(void *ptr);
    功能：释放一块堆内存
    ptr：要释放的堆内存的首地址
    注意：free释放只是使用权限，数据不会全部清理
    注意：不能连续释放，但是可以释放NULL

    void *calloc(size_t nmemb, size_t size);
    功能：从堆内存申请nmemb块，每块size字节大小的内存
    返回值：成功返回申请到的连续内存的首地址，失败返回NULL
    注意：calloc申请到的内存会被初始化为0，速度比malloc慢
    short* p = calloc(20,2) == malloc(40)

    void *realloc(void *ptr, size_t size);
    功能：改变已有的堆内存的大小，size表示调整后的大小，在原有的基础上调大调小
    返回值：调整后内存块的新首地址，一定要重新接收返回值，可能不是在原位置进行调整
        如果无法在原位置调整：
            1、申请一块新的符合大小的内存
            2、拷贝原内存中的数据
            3、释放原内存，返回新内存首地址

四、malloc的内存管理机制
    1、当首次向malloc申请内存，malloc会向操作系统申请内存，操作系统会直接分配33页(1页=4096字节)内存交给malloc管理，但是并不意味着可以越界访问，因为malloc可能把其他的内存分配给"其他人"，这样就会产生脏数据

    2、每个内存块之间会有空隙(4~12字节)，一部分空隙是为了内存对齐，其中一定有4字节记录了malloc的维护信息，这些维护信息决定了下一次malloc分配内存的位置，如果破坏了维护信息，会影响下一次malloc或者free的过程

五、使用堆内存需要注意的问题
    内存泄漏：
        内存无法再使用，也无法被释放，而需要再次使用时只能重新申请内存，然后继续重复以上过程，日积月累后可用的内存越来越少
        注意：一旦进程结束属于该进程的所有资源都会被操作系统回收
        如何尽量地避免内存泄漏：
            谁申请谁释放，谁知道该释放谁释放
        如何判断、定位内存泄漏：
            1、查看内存使用情况
                win 任务管理器
                Linux ps -aux命令
            2、借助代码分析工具 mtrace，检查malloc和free是否成对出现
            3、封装malloc、free，记录申请、释放的信息到日志文件中
    
    内存碎片：
        已经释放了但无法继续使用的内存叫做内存碎片，由于申请和释放的时间不协调导致的，无法完全避免只能尽量减少
        如何减少内存碎片：
            1、尽量使用栈内存
            2、不要频繁地申请、释放内存
            3、尽量申请大块的内存自己管理
    
六、内存清理函数
    #include <strings.h>
    void bzero(void *s, size_t n);
    功能：把一块内存清理为0
    s:内存块的首地址
    n:内存块的字节数

    #include <string.h>
    void *memset(void *s, int c, size_t n);
    功能：把内存块按字节设置为c
    s:内存块的首地址
    c:想要设置的ASCII值
    n:内存块的字节数
    返回值：成功设置后的内存首地址

七、堆内存定义二维数组
    指针数组
        定义n行，m列二维数组
        类型* arr[n];
        for(int i=0; i<n; i++)
        {
            arr[i] = malloc(m*sizeof(类型))；
        }
        注意：每一行的m值可以不同，这种方式可以定义不规则的二维数组
        缺点：申请麻烦、容易产生内存碎片
        优点：可以不规则、对内存要求较低

    数组指针
        类型 (*arrp)[n] = malloc(sizeof(类型)*n*m);
        申请m行n列的二维数组
        缺点：对连续内存要求高，可能申请失败
        优点：申请简单
    注意：所谓的多维数组其实都是用一维数组模拟

    练习1：计算出100~10000之间所有的素数，结果存储在堆内存中，尽量不要浪费内存
        1、先计算有多少个、再一下全部申请出来
        2、一边算，一边申请



            

