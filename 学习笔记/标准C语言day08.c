一、函数递归
    函数自己调用自己的这种行为叫做函数递归，可能会产生死循环
    递归是可以实现分治的这种算法，把一个复杂的大问题，分解成若干个相同的小问题，知道所有问题全部解决
    如何写好递归：
        1、写好出口
        2、解决一个小问题
        3、调用自己
    练习1：计算前N项斐波那契数列    / 不使用循环语句
     1  0 | 1 1 2 3 5 8 13 21 ...  
    f1  f2  f3
    练习1-2：计算第N项斐波那切数列

    递归函数每一次调用都会在栈内存产生一份自己的拷贝，直到执行到达出口，才会释放这一层递归函数，因此与循环相比递归非常耗费内存、速度很慢，因此如果能有循环解决的问题就不要使用递归
        递归优缺点：
            1、好理解、思路清晰
            2、很好地解决非线性问题
            3、耗费内存、速度很慢
    
    练习2：使用递归模拟n层汉诺塔的移动过程
        void hanio(int n,char s,char m,char e);
        //  n是层数  s起点  m中转点  e终点
        hanio(8,'A','B','C');
    思考：
        显示出 0~9的全排列
         0 1 2
         0 2 1
         1 0 2
         1 2 0 
         2 0 1 
         2 1 0

二、指针
什么是指针：
    指针是一种特殊的数据类型，使用它可以定义指针变量，指针变量存储的是整型数据，代表了内存的编号，通过这个编号可以访问对应的内存

为什么要使用指针：
    1、函数之间是相互独立的，但是有时候需要共享变量
        传参是单向值传递
        全局变量容易命名冲突
        使用数组麻烦、还需要额外传递长度
        虽然函数之间命名空间是独立的，但是地址空间是同一个，指针可以解决共享变量的问题
    2、由于函数之间传参是值传递(内存拷贝)，对于字节数较多的变量，值传递的效率较低，如果传递变量的地址只需要传递4 | 8 个字节
    3、堆内存无法取名字，它不像data、bss、stack让变量名与内存建立联系，只能使用指针记录堆内存的地址来访问对应的内存

如何使用指针：
    定义：  类型名* 变量名_p;
            int* num_p;
            int *num_p
        1、指针变量与普通变量的用法有很大区别，建议在取名以p结尾以示区分
        2、指针的类型表示存储的是什么类型变量的地址，它决定了通过这个指针变量可以访问的字节数
        3、一个*只能定义一个指针变量
            int *p1,p2,p3;  //p1是指针 p2p3是int
            int *p1,*p2,*p3;// p1p2p3都是指针
        4、指针变量与普通变量一样默认值是随机的，一般初始化为NULL
    
```c
赋值：变量名_p = 地址;  //必须是有意义且有权限的地址
    指向栈内存：
        int num;
        int* p = &num;        
    指向堆内存：
        int* p = malloc(4) 

解引用：*变量名_p
    通过指针变量中记录的内存的编号去访问对应的内存，该过程可能会产生段错误，原因是里面存储的内存编号是非法的
    注意：访问的字节数由指针定义时类型决定，后面都不会改变

练习3：实现一个交换变量的函数，用这个函数对数组进行排序
    int num1 = 10,num2 = 20;
    func(xxx,xxx);
    num1 == 20,num2 ==10

作业1：实现一个函数计算两个整数的最大公约数、最小公倍数，最大公约数用return返回，最小公倍数使用指针输出型参数处理
```








