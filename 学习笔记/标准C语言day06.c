复习：
    进制转换：
    十进制转二进制：对2求余，直到商为0，过程中余数的逆序就是二进制
    二进制转十进制：2^(n-1) 每位结果相加
    二进制转八进制： 三位二进制对应一位八进制
    二进制转十六进制：四位二进制对应一位十六进制
    代码中0开头是八进制数，0x/0X开头是十六进制
    %o 八进制   %x 十六进制

    原、反、补码：
        正数、无符号数的原、反、补一致
        负数：转换成二进制，除符号位外，其它位按位求反得到反码，反码+1得到补码

        补码转数据：
            无符号直接转数据
            有符号：看最高位0直接转
                    最高位1：补码-1得到反码
                             反码符号位不变，其他按位求反
                             原码转数据
    位运算符：
        ~ 在位运算符中优先级最高
        单目 算术 位 关系 逻辑 三目 赋值 
        int num = 40;
        num = num >> 2 + 1;
        printf("%d",num);
        ^   按位异或
        <<  右边补0
        >>  左边补符号位
        注意：只要表达式中出现了位运算符，转换为二进制计算
    
    自定义函数：
        函数声明
            定义在调用之前，声明可以省略
            声明内容要与定义完全一致
            如果不需要返回值、参数，则一定要写void
            在调用前，没有声明、定义，产生隐式声明的警告
        函数定义
        函数调用

一、函数传参
    1、形参变量、函数内定义的变量都只属于它所在的函数，出了该函数就不能再用
    2、普通实参与形参之间是通过赋值的方式传递数据的(单向值传递)
    3、return 其实是把数据存放到一个公共区域(函数都可以访问)，如果不写return语句，那么就会读取该区域原来的数值，就得到一个垃圾数据
    4、数组作为函数的参数时，中括号中的长度就会丢失，需要额外增加一个变量传递数组的长度
    5、数组作为函数参数传递时，传递是数组的首地址，叫做"址传递"，函数和函数的调用者可以共享同一个数组
    
    练习1：实现函数，找出数组中的最大值
    练习2：实现函数，对数组进行升序排序
    练习3：实现一个函数，查找数组中是否存在某个值，如果存在则返回该值的下标
        int find_arr(int arr[],int len,int key);
    
    设计函数的建议：
        1、一个函数最好就解决一个问题，降低错误率，提高可读性
        2、尽量减少函数之间的依赖层数(降低耦合度)
        3、数据由调用者提供，结果返回给调用者(提高通用性)
        4、考虑函数的非法参数，可以通过返回值的方式告诉调用者参数有误，也可以通过注释方式写明情况(提高函数的健壮性)

二、进程映像
    程序：存储在磁盘上的可执行文件(二进制文件、脚本文件)
    进程：在系统中运行中的程序
    进程映像：指的是进程内存的分布情况
        text 代码段 存储二进制的指令、常量数据，权限是只读的，强制地修改就会产生段错误
        data 数据段    初始化过的全局变量，初始化过的静态局部变量
        bss  静态数据段 未初始化过的全局变量，未初始化过的静态局部变量，进程运行前该段内存会自动清理为0
        stack 栈 局部变量、块变量 由操作系统管理，会在进程运行过程中自动申请、释放内存 内存小
        heap  堆 由程序员手动管理，优点：足够大
    
    局部变量和全局变量：
        全局变量：定义在函数外的变量
            存储位置：data(初始化) 或者 bss(未初始化)
            生命周期：程序开始到程序结束
            作用范围：在程序的任意位置都可以使用
        局部变量：定义在函数内的变量
            存储位置：stack 栈内存
            生命周期：从函数调用开始到函数结束
            作用范围：只能在函数内使用
        块变量：定义在语句块内的变量  if\for\while
            存储位置：stack 栈内存
            生命周期：从函数调用开始到函数结束
            作用范围：只能在语句块内使用
        注意：局部变量可以和全局变量同名，在函数内局部变量会屏蔽同名的全局变量，块变量在语句块内会屏蔽同名的全局、局部变量，因此建议全局变量首字母大写

三、类型限定符
    auto 用于定义自动分配内存、释放内存的变量(局部变量)，不加就代表了加 
        注意：全局变量不能用auto修饰的
        在C11中用于自动识别类型
            auto num = 3.14;
    
    extern  
        声明变量  extern 类型名 变量名;
        告诉编译器此变量已经在别处定义过了，请放心使用
        但是只能临时让编译通过，但是在链接时如果找不到该变量的定义，依然会报错
        不能在声明变量时赋值
        在多文件编程中，假设a.c中定义全局变量N，想要在b.c中使用N，需要在使用前声明该变量
    
    static
        改变存储位置：
            改变局部变量的存储位置，从stack改为data或者bss(取决于是否初始化)
            被它修饰的局部变量叫做静态局部变量
        延长生命周期：
            延长了局部变量的生命周期，直到进程结束
        限制作用范围：
            限制全局变量、函数的作用范围，只能在本文件内使用
            可以防止全局变量、函数命名冲突、也可以防止被别的文件使用
    
    const
        "保护"变量的值不能被显示地修改
        但是可以通过访问内存来修改值
        但是如果修饰的是初始化过的全局变量、初始化过的静态局部变量，则该变量会从data改为text，变成了"常量"，不能强制修改

    volatile
        如果变量的值没有被显示修改，那么在使用该变量时不会从内存中读取，而是继续使用上次读取的结果，这个过程叫做取值优化，一般变量都会进行。
        变量被volatile修饰后，编译器不对该变量进行取值优化，每次都从内存中重新读取
        一般硬件编程时、多线程编程时会使用到
        volatile int num = 10;
        if(num == num)  // 有可能为假
        {

        }

    存储介质：硬盘->内存->高级缓存->寄存器
        register
            申请把变量的存储介质由内存改为寄存器，由于寄存器数量有限不一定申请成功
            注意:寄存器变量不能取地址
    
        typedef
            类型重定义
            定义变量时，如果在类型前面加typedef，那么变量名就变成了这个类型的新的类型名
            typedef int num;
            int a;
            num b;
            注意：typedef不是替换关系



